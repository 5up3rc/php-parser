<!-- Generated by documentation.js. Update this documentation by updating the source code. -->

# engine

Type: Engine

**Parameters**

-   `options`  

**Properties**

-   `lexer` **Lexer** 
-   `parser` **Parser** 
-   `ast` **[AST](#ast)** 
-   `tokens` **[Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** 

## parseEval

parsing eval string as '$x = 1;'

**Parameters**

-   `buffer`  

Returns **[Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)** 

## parseCode

parse php code with '&lt;?php $x = 1;'

**Parameters**

-   `buffer`  

## tokenGetAll

split the buffer into tokens

**Parameters**

-   `buffer`  

## create

Creates a new instance

**Parameters**

-   `options` **[Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** 

Returns **Engine** 

## parseEval

Evaluate the buffer

**Parameters**

-   `buffer`  
-   `options`  

## parseCode

parse php code with '&lt;?php $x = 1;'

**Parameters**

-   `buffer`  
-   `options`  

## tokenGetAll

split the buffer into tokens

**Parameters**

-   `buffer`  
-   `options`  

# lexer

This is the php lexer. It will tokenize the string for helping the
parser to build the AST from its grammar.

**Parameters**

-   `engine`  

**Properties**

-   `EOF` **Integer** 
-   `all_tokens` **[Boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** defines if all tokens must be retrieved (used by token_get_all only)
-   `comment_tokens` **[Boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** extracts comments tokens
-   `mode_eval` **[Boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** enables the evald mode (ignore opening tags)
-   `asp_tags` **[Boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** disables by default asp tags mode
-   `short_tags` **[Boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** enables by default short tags mode
-   `keywords` **[Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** List of php keyword
-   `castKeywords` **[Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** List of php keywords for type casting

## setInput

Initialize the lexer with the specified input

**Parameters**

-   `input`  

## input

consumes and returns one char from the input

**Parameters**

-   `size`  

## unput

revert eating specified size

**Parameters**

-   `size`  

## getState

Gets the current state

## setState

Sets the current lexer state

**Parameters**

-   `state`  

# T_DOC_COMMENT

Behaviour : <https://github.com/php/php-src/blob/master/Zend/zend_language_scanner.l#L1927>

# T_END_HEREDOC

edge case : empty now doc \*

# ch

SCANNING CONTENTS \*

# ch

edge case : empty here doc \*

# ch

SCANNING CONTENTS \*

# parser

The PHP Parser class

**Parameters**

-   `lexer`  

**Properties**

-   `EOF` **Integer** 
-   `lexer` **Lexer** 
-   `token` **(Integer | [String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String))** 
-   `extractDoc` **[Boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** 
-   `debug` **[Boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** 

## getTokenName

helper : gets a token name

**Parameters**

-   `token`  

## parse

main entry point : converts a source code to AST

**Parameters**

-   `code`  

## raiseError

Raise an error

**Parameters**

-   `message`  
-   `msgExpect`  
-   `expect`  
-   `token`  

## error

handling errors

**Parameters**

-   `expect`  

## node

Creates a new AST node

**Parameters**

-   `name`  

## expectEndOfStatement

expects an end of statement or end of file

## expect

force to expect specified token \*

**Parameters**

-   `token`  

## text

returns the current token contents \*

## next

consume the next token \*

## ignoreComments

consume comments (if found) \*

## nextWithComments

consume the next token (including doc) \*

## is

Check if token is of specified type

**Parameters**

-   `type`  

## read_token

convert an token to ast \*

## read_list

Helper : reads a list of tokens / sample : T_STRING ',' T_STRING ...
<ebnf>
list ::= separator? ( item separator )\* item
</ebnf>

**Parameters**

-   `item`  
-   `separator`  
-   `preserveFirstSeparator`  
-   `withDoc`  

# ignoreStack

outputs some debug information on current token \*

# read_array

Parse an array
<ebnf>
array ::= T_ARRAY '(' array_pair_list ')' | '[' array_pair_list ']'
</ebnf>

# read_array_pair_list

Reads an array entry item
<ebnf>
array_pair_list ::= '&' w_variable | (expr (T_DOUBLE_ARROW (expr | '&' w_variable) )?)
</ebnf>

# read_dim_offset

<ebnf>
 dim_offset ::= expr?
</ebnf>

# read_class

reading a class
<ebnf>
class ::= class_scope? T_CLASS T_STRING (T_EXTENDS NAMESPACE_NAME)? (T_IMPLEMENTS (NAMESPACE_NAME ',')\* NAMESPACE_NAME)? '{' CLASS_BODY '}'
</ebnf>

# read_class_scope

Read the class visibility
<ebnf>
  class_scope ::= (T_FINAL | T_ABSTRACT)?
</ebnf>

# read_class_body

Reads a class body
<ebnf>
  class_body ::= (member_flags? (T_VAR | T_STRING | T_FUNCTION))\*
</ebnf>

# read_variable_list

Reads variable list
<ebnf>
 variable_list ::= (variable_declaration ',')\* variable_declaration
</ebnf>

# read_variable_declaration

Reads a variable declaration
<ebnf>
 variable_declaration ::= T_VARIABLE '=' scalar
</ebnf>

# read_constant_list

Reads constant list
<ebnf>
 constant_list ::= T_CONST (constant_declaration ',')\* constant_declaration
</ebnf>

# read_constant_declaration

Reads a constant declaration
<ebnf>
 constant_declaration ::= T_STRING '=' expr
</ebnf>

# read_member_flags

Read member flags

Returns **any** array
 1st index : 0 => public, 1 => protected, 2 => private
 2nd index : 0 => instance member, 1 => static member
 3rd index : 0 => normal, 1 => abstract member, 2 => final member

# read_interface

reading an interface
<ebnf>
interface ::= class_scope? T_INTERFACE T_STRING (T_EXTENDS (NAMESPACE_NAME ',')\* NAMESPACE_NAME)? '{' INTERFACE_BODY '}'
</ebnf>

# read_interface_body

Reads an interface body
<ebnf>
  interface_body ::= (member_flags? (T_CONST | T_FUNCTION))\*
</ebnf>

# read_trait

reading a trait
<ebnf>
trait ::= T_TRAIT T_STRING (T_EXTENDS (NAMESPACE_NAME ',')_ NAMESPACE_NAME)? '{' FUNCTION_ '}'
</ebnf>

# read_trait_use_statement

reading a use statement
<ebnf>
trait_use_statement ::= namespace_name (',' namespace_name)\* ('{' trait_use_alias '}')?
</ebnf>

# read_trait_use_alias

Reading trait alias
<ebnf>
trait_use_alias ::= namespace_name ( T_DOUBLE_COLON T_STRING )? (T_INSTEADOF namespace_name) | (T_AS member_flags? T_STRING)
</ebnf>

# read_expr_item

<ebnf>
Reads an expression
 expr ::= @todo
</ebnf>

# read_new_expr

<ebnf>
   new_expr ::= T_NEW (namespace_name function_argument_list) | (T_CLASS ... class declaration)
</ebnf>
<https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L850>

# read_class_name_reference

Reads a class name
<ebnf>
class_name_reference ::= namespace_name | variable
</ebnf>

# read_assignment_list

<ebnf>
  assignment_list ::= assignment_list_element (',' assignment_list_element?)\*
</ebnf>

# read_assignment_list_element

<ebnf>
 assignment_list_element ::= expr | expr T_DOUBLE_ARROW expr
</ebnf>

# is_reference

checks if current token is a reference keyword

# is_variadic

checks if current token is a variadic keyword

# read_function

reading a function
<ebnf>
function ::= function_declaration code_block
</ebnf>

# read_function_declaration

reads a function declaration (without his body)
<ebnf>
function_declaration ::= T_FUNCTION '&'?  T_STRING '(' parameter_list ')'
</ebnf>

# read_lexical_var

<ebnf>
lexical_var ::= '&'? T_VARIABLE
</ebnf>

# read_parameter_list

reads a list of parameters
<ebnf>
 parameter_list ::= (parameter ',')\* parameter?
</ebnf>

# read_parameter

<ebnf>
 parameter ::= type? '&'? T_ELLIPSIS? T_VARIABLE ('=' expr)?
</ebnf>

# read_function_argument_list

<ebnf>
 function_argument_list ::= '(' (argument_list (',' argument_list)\*)? ')'
</ebnf>

# read_argument_list

<ebnf>
   argument_list ::= T_ELLIPSIS? expr
</ebnf>

# read_type

read type hinting
<ebnf>
 type ::= T_ARRAY | T_CALLABLE | namespace_name
</ebnf>

# read_if

<ebnf>
 if ::= '(' expr ')' ':' ...
</ebnf>

# read_if_expr

reads an if expression : '(' expr ')'

# read_elseif_short

reads an elseif (expr): statements

# read_else_short

# read_short_form

Reads a short form of tokens

# read_while

Reads a while statement

# read_foreach

<ebnf>
foreach ::= '(' expr T_AS foreach_variable (T_DOUBLE_ARROW foreach_variable)? ')' statement
</ebnf>

# read_foreach_variable

<ebnf>
foreach_variable = ('&'? variable) | (T_LIST '(' assignment_list ')')
</ebnf>

# read_start

<ebnf>
start ::= (namespace | top_statement)\*
</ebnf>

# read_namespace

<ebnf>
namespace ::= T_NAMESPACE namespace_name? '{'
   top_statements
'}'
| T_NAMESPACE namespace_name ';' top_statements
</ebnf>

# read_namespace_name

reading a namespace name
<ebnf>
 namespace_name ::= T_NS_SEPARATOR? (T_STRING T_NS_SEPARATOR)\* T_STRING
</ebnf>

# read_use_statements

<ebnf>
use_statements ::=
     use_statements ',' use_statement
     | use_statement
</ebnf>

# read_inline_use_declaration

<ebnf>
 inline_use_declaration ::= ...
</ebnf>

# read_use_statement_mixed

<ebnf>
  use_statement_mixed ::=
      use_statement  (T_AS T_STRING | '{' read_inline_use_declaration '}' )
      (',' read_use_statement)\*
</ebnf>

# read_use_statement

<ebnf>
use_statement ::= (
 (T_FUNCTION | T_CONST)? namespace_name
 )
</ebnf>

# read_scalar

<ebnf>
 scalar ::= T_MAGIC_CONST
      | T_LNUMBER | T_DNUMBER
      | T_START_HEREDOC T_ENCAPSED_AND_WHITESPACE? T_END_HEREDOC
      | '"' encaps_list '"'
      | T_START_HEREDOC encaps_list T_END_HEREDOC
      | namespace_name (T_DOUBLE_COLON T_STRING)?
</ebnf>

# read_dereferencable

Handles the dereferencing

# read_encapsed_string_item

<ebnf>
encapsed_string_item ::= T_ENCAPSED_AND_WHITESPACE | T_DOLLAR_OPEN_CURLY_BRACES ... | variable  | T_CURLY_OPEN variable '}'
</ebnf>

# read_encapsed_string

Reads an encapsed string

# get_magic_constant

Constant token

# read_top_statements

reading a list of top statements (helper for top_statement_)
<ebnf>
 top_statements ::= top_statement_
</ebnf>

# read_top_statement

reading a top statement
<ebnf>
 top_statement ::=
      namespace | function | class
      | interface | trait
      | use_statements | const_list
      | statement
</ebnf>

# read_inner_statements

reads a list of simple inner statements (helper for inner_statement_)
<ebnf>
 inner_statements ::= inner_statement_
</ebnf>

# read_const_list

Reads a list of constants declaration
<ebnf>
  const_list ::= T_CONST T_STRING '=' expr (',' T_STRING '=' expr)\* ';'
</ebnf>

# read_declare_list

Reads a list of constants declaration
<ebnf>
  const_list ::= T_CONST T_STRING '=' expr (',' T_STRING '=' expr)\*
</ebnf>

# read_inner_statement

reads a simple inner statement
<ebnf>
 inner_statement ::= '{' inner_statements '}' | token
</ebnf>

# read_statement

Reads statements

# read_code_block

<ebnf>
 code_block ::= '{' (inner_statements | top_statements) '}'
</ebnf>

# read_switch

Reads a switch statement
<ebnf>
 switch ::= T_SWITCH '(' expr ')' switch_case_list
</ebnf>

# read_switch_case_list

<ebnf>
 switch_case_list ::= '{' ';'? case_list_ '}' | ':' ';'? case_list_ T_ENDSWITCH ';'
</ebnf>

# read_case_list

<ebnf>
  case_list ::= ((T_CASE expr) | T_DEFAULT) (':' | ';') inner_statement\*
</ebnf>

# read_try

<ebnf>
 try ::= T_TRY '{' inner_statement_ '}'
         (
             T_CATCH '(' namespace_name variable ')' '{'  inner_statement_ '}'
         )_
         (T_FINALLY '{' inner_statement_ '}')?
</ebnf>

# read_comment

Comments with // or #

# read_doc_comment

Comments with / \*\* \*\* /

# read_variable

<ebnf>
  variable ::= ...complex @todo
</ebnf>
<code>
 $var                      // simple var
 classname::CONST_NAME     // dynamic class name with const retrieval
 foo()                     // function call
 $var->func()->property    // chained calls
</code>

# read_encaps_var_offset

<https://github.com/php/php-src/blob/493524454d66adde84e00d249d607ecd540de99f/Zend/zend_language_parser.y#L1231>

# read_reference_variable

<ebnf>
 reference_variable ::=  simple_variable ('[' OFFSET ']')\* | '{' EXPR '}'
</ebnf>
<code>
 $foo[123];      // foo is an array ==> gets its entry
 $foo{1};        // foo is a string ==> get the 2nd char offset
 ${'foo'}[123];  // get the dynamic var $foo
 $foo[123]{1};   // gets the 2nd char from the 123 array entry
</code>

# read_simple_variable

<ebnf>
 simple_variable ::= T_VARIABLE | '$' '{' expr '}' | '$' simple_variable
</ebnf>

# AST

The AST builder class

**Parameters**

-   `withPositions`  
-   `withSource`  

**Properties**

-   `withPositions` **[Boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** 
-   `withSource` **[Boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** 

## prepare

Prepares an AST node

**Parameters**

-   `kind`  
-   `parser`  

# Location

Defines the location of the node (with it's source contents as string)

**Parameters**

-   `source`  
-   `start`  
-   `end`  

**Properties**

-   `source` **([String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) | null)** 
-   `start` **[Position](#position)** 
-   `end` **[Position](#position)** 

# Position

Each Position object consists of a line number (1-indexed) and a column number (0-indexed):

**Parameters**

-   `line`  
-   `column`  
-   `offset`  

**Properties**

-   `line` **[Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** 
-   `column` **[Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** 
-   `offset` **[Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** 

# Program

**Extends Block**

The main program node

**Properties**

-   `children` **[Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)&lt;[Node](#node)>** 

# Block

**Extends Statement**

A block statement, i.e., a sequence of statements surrounded by braces.

**Properties**

-   `children` **[Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)&lt;[Node](#node)>** 

# Statement

**Extends Node**

Any statement.

# Namespace

**Extends Block**

The main program node

**Properties**

-   `name` **[Identifier](#identifier)** 
-   `withBrackets` **[Boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** 

# Identifier

**Extends Node**

Defines an identifier node

**Properties**

-   `name` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** 
-   `fqn` **[boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** 

# Node

A generic AST node

**Parameters**

-   `type`  
-   `location`  

**Properties**

-   `loc` **([Location](#location) | null)** 
-   `type` **[String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** 

## extends

Helper for extending the Node class

**Parameters**

-   `constructor` **[Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)** 

Returns **[Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)** 
